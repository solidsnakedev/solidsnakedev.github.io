---
title: "Anatomy of Midnight Contracts from a Cardano Developer's Perspective"
description: "Deep dive into Midnight's privacy focused smart contracts from a Cardano developer's perspective"
pubDate: 2026-01-07
author: "SolidSnakeDev"
tags: ["midnight", "cardano", "smart contracts", "privacy", "zkp"]
---

# Anatomy of Midnight Contracts from a Cardano Developer's Perspective

If you've been building on Cardano, you've probably heard about Midnight, the privacy focused partner chain that shares some DNA with the ecosystem you know. Maybe you've seen the Compact code snippets floating around and thought "that looks like TypeScript with weird keywords."

You're not wrong. But here's the thing: the surface level familiarity can be misleading.

Midnight isn't "Cardano with ZK bolted on." It's a fundamentally different programming model that happens to share lineage, infrastructure relationships, and some philosophical alignment with Cardano. The eUTXO intuition you've built? Some of it transfers. A lot of it needs rewiring.

This post walks through the anatomy of a Midnight contract from the perspective of someone who's spent time wrestling with validators, datums, and the joys of UTXO contention. We'll use a real contract, OpenZeppelin's ShieldedERC20, as our dissection subject.

The goal isn't to convince you that one model is better. It's to build mental bridges so you can evaluate Midnight on its own terms, and maybe pick up some ideas that translate back to how you think about privacy and state in your Cardano work.

Let's start with the biggest shift.

## The Core Mental Model Shift

Here's the uncomfortable truth upfront: your validator brain needs to take a back seat.

In Cardano, you write validators that react. A transaction shows up, carries some datum and redeemer, and your script says "yes, this spend is allowed" or "no, rejected." The validator doesn't do anything. It just judges whether what the transaction proposes is acceptable. The transaction itself carries the state transition.

Midnight flips this. You write circuits that act. When a user calls a circuit, it executes logic, reads and mutates state, and produces outputs. The circuit doesn't validate a transition someone else defined. It is the transition.

| Cardano | Midnight |
|---------|----------|
| Validator receives transaction, says yes/no | Circuit executes, mutates state, returns results |
| Transaction carries the state transition | Circuit defines the state transition |
| Datum/redeemer are inputs to validation | Ledger fields are directly readable/writable |
| Public by default, hide things explicitly | Private by default, disclose things explicitly |
| On chain script execution | Local execution → ZK proof → on chain verification |

That last row is worth sitting with. In Cardano, your script runs on chain during validation. In Midnight, your circuit runs locally on the user's machine. A proof server generates a ZK proof that the execution was correct. Only the proof and public outputs hit the chain. The network verifies the proof and applies the state changes. It never re executes your logic.

This means the "transaction" in Midnight is essentially: "here's a proof that I ran this circuit correctly, here's what should change in public state." The chain doesn't need to trust the user's execution. The math guarantees it.

If you're used to thinking "what can an attacker put in the redeemer to break my validator?" That framing doesn't quite apply here. The circuit is the logic. You can't lie about executing it because the proof wouldn't verify.

## Anatomy of a Contract: Walking Through ShieldedERC20

Let's look at real code. OpenZeppelin published a ShieldedERC20 contract that demonstrates the key structural elements of a Midnight contract. It's marked "DO NOT USE IN PRODUCTION" due to current network limitations, but it's a perfect teaching specimen.

Here's the skeleton:

```rust
pragma language_version >= 0.18.0;

module ShieldedERC20 {
  import CompactStandardLibrary;
  import Utils prefix Utils_;
  import "../../node_modules/@openzeppelin/midnight-apps-math/dist/Bytes32" prefix Bytes32_;

  // State declarations
  export ledger _counter: Counter;
  export ledger _nonce: Bytes<32>;
  export ledger _totalSupply: Uint<128>;
  export sealed ledger _domain: Bytes<32>;
  export sealed ledger _name: Opaque<"string">;
  export sealed ledger _symbol: Opaque<"string">;
  export sealed ledger _decimals: Uint<8>;
  export ledger _type: Bytes<32>;

  // Circuits
  export circuit initialize(...): [] { ... }
  export circuit name(): Opaque<"string"> { ... }
  export circuit mint(...): CoinInfo { ... }
  export circuit burn(...): SendResult { ... }
}
```

Let's break down each piece.

### pragma language_version
Version pinning. Compact is evolving, so you lock to a minimum version to avoid breaking changes. Similar to how you'd pin an Aiken compiler version, it's about the high level language, not the underlying execution layer.

### module

The container for everything. A module is a namespace that encapsulates state, circuits, and types. Definitions are private by default unless you explicitly export them.

In Cardano terms, think of a module as roughly one "script" worth of logic, except it can hold its own persistent state rather than relying on UTXOs carrying datums around.

### import with prefix
Composition without name collision. When you write:

```rust
import Utils prefix Utils_;
```

Everything from the Utils module becomes accessible as `Utils_functionName`. This is how you build contracts from reusable pieces. Import access control modules, math libraries, token standards, whatever.

The module system allows contracts to call circuits in other deployed contracts too. You can hold a reference to another contract in a ledger field and call its exported circuits. But you can't access another contract's internal state directly. Only its public interface.

### ledger vs sealed ledger

This is where Cardano intuition partially helps.

**ledger** fields are mutable on-chain state. They persist across transactions and can be read or written by circuits. Multiple fields, different types, all living directly in the contract.

**sealed ledger** fields are write once. They can only be set during contract deployment (in the constructor or initialization circuits). After that, they're frozen. The compiler enforces this statically. If a sealed field is reachable from an exported circuit, you get an error.

For Cardano devs: sealed is like parameterizing a script at deployment time. You know how you might compile a validator with a specific policy ID or admin key baked in? Same energy. The token name, symbol, decimals, and domain are set once when the contract is deployed and never change.

### export ledger vs plain ledger

The export keyword on a ledger field controls external visibility:

- `export ledger`: visible to the TypeScript SDK and external tooling
- `ledger` (no export): only visible to circuits within this module

This isn't about privacy in the ZK sense. All ledger state is public on chain. It's about API surface. What do you want external callers to see?

### export circuit

These are your callable endpoints. When a user interacts with the contract, they're calling an exported circuit.

```rust
export circuit mint(recipient: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<64>): CoinInfo {
  // ...
}
```

The function signature tells you: takes a recipient and amount, returns a CoinInfo describing the minted token.

Non exported circuits are internal helpers. They're callable from other circuits in the module but not from outside.

## The Privacy Boundary: disclose() and Witnesses

Here's where Midnight gets interesting, and where Cardano devs need to rewire the most.

In Cardano, everything is public by default. Your datum sits on chain for anyone to read. Your redeemer is visible in the transaction. If you want privacy, you architect around it: hashing, commit reveal schemes, off chain coordination. Privacy is something you build.

Midnight inverts this. Everything is private by default. If you want something public, you explicitly disclose() it. Privacy is something you opt out of.

### The disclose() function

Look at this circuit from ShieldedERC20:

```rust
export circuit initialize(
  initNonce: Bytes<32>,
  name_: Opaque<"string">,
  symbol_: Opaque<"string">,
  decimals_: Uint<8>,
  domain_: Bytes<32>
): [] {
  _nonce = disclose(initNonce);
  _domain = disclose(domain_);
  _name = disclose(name_);
  _symbol = disclose(symbol_);
  _decimals = disclose(decimals_);
}
```

Every parameter comes in as private. The Compact compiler tracks this. It runs what they call a "witness protection program" (an abstract interpreter) that follows private data through your code. If you try to:

- Store a private value in a ledger field
- Return a private value from an export circuit
- Pass private data to another contract

...without wrapping it in disclose(), the compiler aborts with an error. You literally can't build the contract.

The disclose() wrapper doesn't transform or encrypt the data. It's a declaration of intent. You're telling the compiler "yes, I know this was private, and I'm authorizing its disclosure." Best practice is to place disclose() as close to the disclosure point as possible, so you don't accidentally authorize leaking data that flows through multiple code paths.

This is a mental shift. In Cardano, you worry "what data am I exposing?" In Midnight, the compiler forces you to explicitly answer that question for every piece of potentially private data.

### Witnesses: Private Data at Runtime
Witnesses are where Midnight's privacy model gets its power.

In the Compact contract, you declare a witness signature. Just the name and types, no implementation:

```rust
witness getSecretKey(): Bytes<32>;
```

The actual implementation lives in TypeScript, in your DApp code. When the circuit executes and hits a witness call:

1. Execution pauses
2. The runtime calls out to your TypeScript function
3. Your function returns private data (maybe from local storage, user input, a hardware wallet)
4. That data enters the circuit as private by default
5. The circuit continues, using that data in computations
6. Only values wrapped in `disclose()` become public

The ZK proof guarantees the circuit executed correctly with some valid witness data, without revealing what that data was.

For Cardano devs, there's no direct equivalent. The closest mental model might be: imagine if your validator could call out to the user's wallet during validation to get a secret, use that secret in the validation logic, and the chain would only see "validation passed". Never the secret itself.

Redeemers are static data attached to transactions. Witnesses are runtime callbacks that inject private data during execution.

### What This Enables

Think about what you can build with this:

- Prove you have sufficient balance without revealing your actual balance
- Prove you're over 18 without revealing your birthdate
- Prove you own a credential without revealing which credential
- Prove a computation was done correctly without revealing the inputs

The contract logic verifies properties of private data. The chain verifies the contract logic ran correctly. Nobody except the user ever sees the actual data.

## State Model: From eUTXO to Account Based Ledger
We covered the ledger and sealed ledger syntax earlier. Now let's dig into how the state model behaves differently from what you know.

### The Datum Analogy (and Its Limits)
You can squint and say "ledger fields are like datums." Both are on chain state. Both persist across transactions.

But the mechanics differ:

| Datum (Cardano) | Ledger (Midnight) |
|----------------|-------------------|
| Lives in UTXOs, moves with them | Lives in the contract directly |
| Transaction carries old and new datum | Circuit mutates in place |
| Validator receives datum as read only input | Circuit reads and writes directly |
| One datum per UTXO | Multiple typed fields per contract |

In Cardano, updating state means consuming a UTXO and producing a new one with a fresh datum. Your validator checks that the transition is legal. The transaction itself carries the "before" and "after."

In Midnight, you just write to the field:

```rust
_totalSupply = _totalSupply + disclose(amount) as Uint<128>;
```

No UTXO choreography. The ZK proof guarantees the mutation followed your circuit logic. The chain applies it atomically.

### Built in Abstract Data Types
Midnight provides specialized types optimized for on chain state:

- **Counter**: atomic increment/decrement operations
- **Set<T>**: membership tracking
- **Map<K, V>**: key value storage
- **MerkleTree<n, T>**: ZK friendly authenticated data structures

These aren't just convenience wrappers. They're designed for contention resistance and efficient ZK proof generation.

The Counter type is instructive:

```rust
export ledger _counter: Counter;

// Inside a circuit:
_counter.increment(1);
```

Instead of "read current value → add one → write new value" (which creates contention if multiple transactions try simultaneously), you express the intent: "increment by one." The ledger handles these atomically, and multiple increments can succeed without conflicting.

Compare this to Cardano, where you'd have a datum holding an integer, and concurrent updates would fight over the same UTXO. You'd need batchers or multi UTXO designs to parallelize.

## The Coin Infrastructure: ZSwap and Native Tokens

If you've worked with Cardano native assets, you'll find some familiar ground here, and some surprises.

Midnight has a built-in shielded coin system called ZSwap. The ShieldedERC20 contract interacts with it through standard library primitives:

```rust
const ret = mintToken(_domain, disclose(amount), _nonce, disclose(recipient));
receive(disclose(coin));
sendImmediate(disclose(coin), burnAddress(), disclose(amount));
```

### The Primitives

- **mintToken**: creates a new ZSwap output (a shielded coin)
- **receive**: claims a coin into the contract's control
- **sendImmediate**: spends a coin by sending it to a recipient

These operate on CoinInfo structures that describe tokens: their "color" (type), value, and ownership.

### Colored Coins on a UTXO Foundation

Here's where your Cardano intuition helps. Under the hood, Midnight's native tokens use a "colored coins" approach on a UTXO base layer. This means:

Transfer logic is ledger managed, not contract managed.

Sound familiar? On Cardano, once you mint a native asset, it moves freely between wallets without involving the minting policy. The policy controls minting and burning, not transfers.

Midnight works the same way. A contract can mint tokens and define minting rules, but once tokens exist, users can transfer them directly through the UTXO layer without calling the contract.

This is why the ShieldedERC20 has that warning at the top:

```rust
/**
 * @notice This module should NOT be used due to current limitations:
 *
 * - No custom spend logic. Once users receive tokens, there's no mechanism to
 * enforce any token behaviors.
 *
 * - Cannot guarantee proper total supply accounting. Users can burn tokens
 * manually by sending them to the burn address.
 */
```

The contract tracks _totalSupply, but if someone sends tokens directly to the burn address outside the contract, that accounting breaks. The contract never sees the burn happen.

For Cardano devs: this is exactly like how your minting policy can't prevent someone from sending tokens to a burn address. The policy only runs on mint/burn transactions, not transfers.

### Recipient Types

You'll see this pattern throughout:

```rust
Either<ZswapCoinPublicKey, ContractAddress>
```

This represents who can receive tokens:

- `ZswapCoinPublicKey`: a user's wallet (an individual)
- `ContractAddress`: another deployed contract

It's not "shielded vs transparent" exactly. Both are part of the ZSwap system. The distinction is whether the recipient is a person or a contract. Sending to a contract address lets that contract later claim and process the coin through its own logic.

### The Current Limitation

The ShieldedERC20 warning highlights a gap in the current Midnight network: no custom spend logic. On Cardano, you can lock tokens at a script address with a validator that enforces spending conditions. Midnight's current model doesn't support this for the native coin layer. Once tokens leave the contract, they're freely transferable.

This matters for things like:

- Stablecoins that need freeze or pause functionality
- Tokens with transfer restrictions
- Any asset that needs ongoing spend validation

The Midnight team has flagged this for future work. For now, the recommendation is to use unshielded tokens for cases where you need control over transfers.

## Transaction Lifecycle: Proofs Instead of Signatures

In Cardano, you build a transaction, sign it with your keys, and submit it. The network executes your validators on-chain to verify the spend is authorized.

Midnight's flow is different. The heavy lifting happens locally, and the chain only verifies a proof.

### The Flow

1. **User triggers a circuit call**: Your DApp invokes an exported circuit with some arguments

2. **Local execution**: The circuit runs on the user's machine. Witnesses get called, private data flows in, state transitions happen. This produces a "transcript" of what should change in public state.

3. **Proof generation**: A local proof server takes the execution trace and generates a ZK proof. This is computationally expensive but happens client side.

4. **Transaction assembly**: The proof, public transcript, and any fee payments get bundled into a transaction. These transactions are typically unsigned. The proof itself is the authorization.

5. **On chain verification**: The network verifies the proof against the contract's verifier key. If valid, the state changes in the transcript are applied atomically.

The chain never re-executes your circuit. It just checks "did this proof come from a valid execution of this contract?" The math guarantees it.

### Failure Modes

This is where Cardano's Phase 1 and Phase 2 distinction has a rough parallel.

**Local failure (like Phase 1):**

If your circuit hits an assert that fails:

```rust
assert (!Utils_isKeyOrAddressZero(recipient), "ShieldedToken: invalid recipient");
```

The execution fails locally. No proof can be generated. No transaction gets built. You can't create a valid proof for a lie. The math doesn't work.

**On chain rejection (like Phase 2):**

If somehow an invalid proof reaches the network, verification fails and the transaction is rejected. No state changes, no fees paid.

**Fallible phase (the new thing):**

Midnight adds a concept Cardano doesn't have: fallible transactions.

A transaction can pass proof verification (the guaranteed phase) but fail during transcript application (the fallible phase). This happens when the state changed between when you generated the proof and when the transaction gets processed.

Example: you prove you're incrementing a counter from 5 to 6, but by the time your transaction lands, someone else already incremented it to 6. Your transcript says "set counter to 6" but that's no longer the valid next state.

In this case:

- 
- Fees are collected (you did submit a valid proof)
- State changes are rolled back
- Transaction is recorded as partial success
This is the cost of optimistic execution. Your proof was valid at the time you generated it, but the world moved on.

## Contention and Concurrency

If you've built a DEX or any high throughput protocol on Cardano, you've felt the pain: multiple users trying to interact with the same UTXO means only one wins per block. The rest fail and retry.

This is why Cardano protocols use batchers, order contracts, and multi UTXO pool designs. You architect around contention because the ledger doesn't solve it for you.

Midnight takes a different approach. Contention is partially handled at the infrastructure level.

### Kachina and Transcript Based Concurrency

Midnight's smart contract protocol (called Kachina) separates private execution from public state application. Users execute circuits locally and produce transcripts of intended state changes.

The key insight: Kachina can reorder and optimize these transcripts. If two transactions don't logically conflict, they can both succeed even if they target the same contract. The system maximizes concurrency by analyzing what each transaction actually does rather than just what it touches.

### ADTs as Contention Resistant Primitives

Remember those built in types like Counter? They're not just convenient. They're designed for concurrent access.

Consider two users both wanting to increment a counter:

**The naive approach (conflicts):**

```
User A: read counter (5) → compute 5+1 → write 6
User B: read counter (5) → compute 5+1 → write 6
```

Both read 5, both write 6. One of them is wrong. The final value should be 7.

**The ADT approach (no conflict):**

```
User A: increment(1)
User B: increment(1)
```

Neither transaction asserts what the current value is. They just say "add one." The ledger applies both, order doesn't matter, final value is correct.

This is why Midnight documentation recommends designing around non conflicting operations rather than read, assert, write patterns. The ADTs make this natural.

### The Fallibility Trade-off

When conflicts do happen, Midnight's fallibility model handles it gracefully:

- **Guaranteed phase:** Proof is verified, fees collected
- **Fallible phase:** Transcript application is attempted. If state conflicts exist, changes roll back but fees are kept.

You pay for the failed attempt, but the system doesn't break. Your DApp can catch this and retry with fresh state.

### What This Means for Cardano Devs

**On Cardano,** you solve contention with architecture:

- Batchers that serialize orders
- Order UTXOs that users create, batchers process
- Multi pool designs that spread load

**On Midnight,** the infrastructure handles more of this:

- Kachina optimizes transaction ordering
- ADTs allow non conflicting concurrent updates
- Fallibility provides graceful degradation
You still need to think about contention. A poorly designed contract can still bottleneck. But the default tooling gives you more room before you hit walls.
The batcher pattern might still make sense for some Midnight applications, but it's not the immediate default like it is on Cardano.

## What Transfers from Cardano and What Does Not

After walking through all of this, let's get practical. What parts of your Cardano experience carry over, and what needs rewiring?

### Transfers Well

**UTXO intuition for the coin layer**  
Midnight's native tokens sit on a UTXO foundation. The colored coins model, the separation between minting policy and transfer freedom, the idea that tokens move independently of contract logic. This maps directly to Cardano native assets. Your mental model of "policy controls minting, ledger handles transfers" works here.

**Deployment time parameters**  
sealed ledger fields are parameterized scripts by another name. You configure the contract at deployment, values are frozen, compiler enforces immutability. Same pattern, different syntax.

**Separating off chain and on chain concerns**  
Cardano trained you to think carefully about what happens in transaction building versus what happens in validation. Midnight takes this further as circuits execute entirely off chain, only proofs hit the chain. The discipline of "prepare everything off chain, verify on chain" translates, just more extremely.

**Native asset mental model**  
Multi asset ledgers, tokens identified by policy or color, assets moving as first class values. Cardano and Midnight share this. You're not wrapping tokens in contract calls like ERC20. Assets are assets.

**Thinking about failure modes**  
Cardano's Phase 1 and Phase 2 distinction teaches you to reason about "can't build the transaction" versus "transaction fails on chain." Midnight has a similar split (local assertion failure vs proof verification failure), plus the fallibility phase. The habit of asking "where can this fail and what happens?" carries over.
Requires Rewiring
Imperative mutation vs declarative validation
This is the big one. Cardano validators are pure functions that approve or reject. Midnight circuits are imperative procedures that execute and mutate. You're not asking "is this transition valid?" You're defining what the transition is. The shift from judge to actor takes adjustment.
Privacy first thinking
On Cardano, you assume everything is visible and design around it. On Midnight, you assume everything is private and explicitly disclose what needs to be public. The disclose() discipline inverts your default stance on data visibility.

**Witnesses as runtime callbacks**  
Nothing in Cardano prepares you for witnesses. Redeemers are static data. Witnesses are functions that get called during execution to inject private data. The idea of "pause circuit, call out to TypeScript, get secret, continue" has no Cardano equivalent.

**Account based contract state**  
No more datum threading. No more UTXO consumption and production to update state. You read and write fields directly. If you're deeply wired for eUTXO state management, this feels almost too easy, and you'll need to rebuild intuition about what can go wrong.

**Contention handled differently**  
On Cardano, contention is your problem to architect around. On Midnight, the infrastructure helps. But you need to learn how it helps (ADTs, Kachina, fallibility) to design contracts that take advantage of it.

## Conclusion
Midnight isn't Cardano with a privacy feature bolted on. It's a different paradigm that happens to share lineage, some infrastructure, and a commitment to doing things properly.
The eUTXO model taught you to think in terms of validation: transactions propose, validators approve. Midnight asks you to think in terms of execution: circuits run, proofs verify, state changes. The shift from "is this allowed?" to "this is what happens" takes time to internalize.
What makes Midnight interesting for Cardano devs isn't just the privacy angle. It's seeing a different answer to questions you've wrestled with:

- How do you manage shared state? (Account model with ADTs instead of UTXO choreography)
- How do you handle contention? (Kachina transcripts and fallibility instead of batchers)
- How do you protect sensitive data? (Privacy by default with explicit disclosure instead of architectural workarounds)

Some of these ideas might inform how you think about Cardano designs. Some might just be interesting alternatives. Either way, understanding both models makes you a better blockchain developer.

If you want to dig deeper:

- [Midnight Docs](https://docs.midnight.network/): official documentation
- [OpenZeppelin ShieldedERC20](https://github.com/OpenZeppelin/midnight-apps/blob/main/contracts/shielded-token/src/openzeppelin/ShieldedERC20.compact): the contract we dissected
- [Midnight Academy](https://academy.midnight.network/): structured learning path

The ZK abstraction means you write TypeScript like code, not low level circuits. The barrier to experimenting is lower than you might expect. Spin up a testnet wallet, deploy a counter contract, call some circuits. The best way to internalize a new model is to build something.

Your Cardano experience isn't baggage here. It's context. Use it.
